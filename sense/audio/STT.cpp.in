/* 
 * File: SSTT.cpp
 * Author: Dagim Sisay <dagiopia@gmail.com>
 * License: AGPL
 * Date: May, 2018
*/

#include "sense/audio/STT.hpp"

// Data
void (*uf_pt)(const char *s); //user defined func
void (*get_audio) (void *buffer, uint32_t size); //func_a
//std::thread *run;
bool is_running;
ps_decoder_t *ps;
cmd_ln_t *cfg;
ad_rec_t *ad;
uint8 utt_started, in_speech;

//AudioCap
AudioCap ac;

//socket
int fd, cl;
struct sockaddr_un addr;



void init_ps()
{
	is_running = false;
	cfg = cmd_ln_init(NULL, ps_args(), TRUE,
	                  "-hmm", "@POCKETSPHINX_MODEL_DIR@/en-us/en-us",
	                  "-lm", "@POCKETSPHINX_MODEL_DIR@/en-us/en-us.lm.bin",
	                  "-dict", "@POCKETSPHINX_MODEL_DIR@/en-us/cmudict-en-us.dict",
	                  "-remove_noise", "yes",
	                  "-logfn", "/dev/null",
	                  NULL);
	if( cfg == NULL) { fprintf(stderr, "Error Creating Config Object\n"); exit(1); }
	ps = ps_init(cfg);
	if (ps == NULL) { fprintf(stderr, "Error Initializing Recognizer\n"); exit(1); }
	
	/* start ps utterance */
	if (ps_start_utt(ps) < 0) {
		fprintf(stderr, "Error Starting Utterance\n");
		exit(1);
	}
	 
	utt_started = FALSE;
	printf("Ready....\n"); //XXX Remove when done
}

void init_ad()
{
	ad = ad_open();
	if(ad == NULL) { fprintf(stderr, "Error Opening Device\n"); exit(1); }
	if(ad_start_rec(ad) < 0) {
		fprinf(stderr, "Error Starting Recording\n");
		exit(1);
	}
}


void init_socket(std::string address, bool client)
{
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if(fd == -1) { fprintf(stderr, "Error Creating Socket\n"); exit(1); }

	memset(&addr, 0, sizeof(addr);
	strncpy(addr.sun_path, address.c_str(), sizeof(addr.sun_path)-1);
	unlink(address.c_str());

	if(client){
		if(connect(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
			fprintf(stderr, "Error Connecting to Socket: %s\n", address.c_str());
			exit(1);
		}
	}
	else {
		if(bind(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
			fprintf(stderr, "Error Binding Address to Socket:%s\n", 
			                 address.c_str());
			exit(1);
		}
		if(listen(fd, 2) == -1) {
			fprintf(stderr, "Error Listening on Socket:%s\n", address.c_str());
			exit(1);
		}
	}

	send_text = socket_send;
}


void tcstt_ad_init(void (*f)(const char *s))
{
	init_ps();
	init_ad();

	uf_pt = f; //set the callback function
	
	if(ps_ad) {
		std::thread run(tcstt_run);
		run.join();
	}
}


void tcstt_ad_init(std::string address, uint8_t port, bool client)
{
	init_ps();
	init_ad();

	//init socket
	init_socket(address, port, client);
	
	if(ps_ad) {
		std::thread run(tcstt_run);
		run.join();
	}
}

void tcstt_init(bool ps_ad, std::string address, std::string port, bool client)
{
	init_ps();
	if(ps_ad) {
		ad = ad_open_dev("plughw:1,0", SAMPLE_RATE);
		if (ad == NULL) { 
			fprintf(stderr, "Error Opening Device\n"); 
			exit(1); 
		}
		if (ad_start_rec(ad) < 0) {
			fprintf(stderr, "Error Starting Recording\n");
			exit(1);
		}
	}
	else {
		//AudioCap
	}
		
	if (ps_start_utt(ps) < 0) {
		fprintf(stderr, "Error Starting Utterance\n");
		exit(1);
	}
	 
	utt_started = FALSE;
	printf("Ready....\n");

	if(ps_ad) {
		std::thread run(tcstt_run);
		run.join();
	}
	
	is_running = true;
}



void tcstt_close()
{
	 is_running = false;
//    delete run;
}


bool tcstt_is_on()
{
	 return is_running;
}






void tcstt_run()
{
	 int32 k;
	 char const *hyp;
	 int16 adbuf[2048];
	 while (is_running) {
		  if ((k = ad_read(ad, adbuf, 2048)) < 0)
				fprintf(stderr, "Errpr Reading Audio Data\n");
		  ps_process_raw(ps, adbuf, k, FALSE, FALSE);
		  in_speech = ps_get_in_speech(ps);
		  if (in_speech && !utt_started) { 
				utt_started = TRUE;
				printf("Listening...\n") //XXX Remove when done;
		  }
		  if (!in_speech && utt_started) {
				ps_end_utt(ps);
				hyp = ps_get_hyp(ps, NULL);
				if (hyp != NULL)
					 uf_pt(hyp); //printf("Text: %s\n", hyp);

				if (ps_start_utt(ps) < 0)
					 fprintf(stderr, "Error Starting Utterance\n");
				utt_started = FALSE;
				printf("Ready...\n") //XXX Remove when done;
		 }
	}
}
